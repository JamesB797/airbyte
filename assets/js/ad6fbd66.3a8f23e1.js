"use strict";(self.webpackChunkdocu=self.webpackChunkdocu||[]).push([[24589],{73204:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=n(87462),o=(n(67294),n(3905));const a={},i="Error Handling",s={unversionedId:"connector-development/connector-builder-ui/error-handling",id:"connector-development/connector-builder-ui/error-handling",title:"Error Handling",description:'When using the "Test" button to run a test sync of the connector, the Connector Builder UI will not retry failed requests. This is done to reduce the amount of waiting time in between test syncs.',source:"@site/../docs/connector-development/connector-builder-ui/error-handling.md",sourceDirName:"connector-development/connector-builder-ui",slug:"/connector-development/connector-builder-ui/error-handling",permalink:"/connector-development/connector-builder-ui/error-handling",draft:!1,editUrl:"https://github.com/airbytehq/airbyte/blob/master/docs/../docs/connector-development/connector-builder-ui/error-handling.md",tags:[],version:"current",frontMatter:{}},l={},c=[{value:"Backoff strategies",id:"backoff-strategies",level:2},{value:"Constant",id:"constant",level:3},{value:"Example",id:"example",level:4},{value:"Exponential",id:"exponential",level:3},{value:"Example",id:"example-1",level:4},{value:"Wait time from header",id:"wait-time-from-header",level:3},{value:"Example",id:"example-2",level:4},{value:"Wait until time from header",id:"wait-until-time-from-header",level:3},{value:"Example",id:"example-3",level:4},{value:"Response filter",id:"response-filter",level:2},{value:"Response conditions",id:"response-conditions",level:3},{value:"If error message matches",id:"if-error-message-matches",level:4},{value:"Example",id:"example-4",level:5},{value:"and predicate is fulfilled",id:"and-predicate-is-fulfilled",level:4},{value:"Example",id:"example-5",level:5},{value:"and HTTP codes match",id:"and-http-codes-match",level:4},{value:"Example",id:"example-6",level:5},{value:"Then execute action",id:"then-execute-action",level:3},{value:"Error message",id:"error-message",level:3},{value:"Multiple error handlers",id:"multiple-error-handlers",level:2}],d={toc:c},h="wrapper";function p(e){let{components:t,...n}=e;return(0,o.kt)(h,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"error-handling"},"Error Handling"),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},'When using the "Test" button to run a test sync of the connector, the Connector Builder UI will not retry failed requests. This is done to reduce the amount of waiting time in between test syncs.')),(0,o.kt)("p",null,"Error handlers allow for the connector to decide how to continue fetching data according to the contents of the response from the partner API. Depending on attributes of the response such as status code, text body, or headers, the connector can continue making requests, retry unsuccessful attempts, or fail the sync."),(0,o.kt)("p",null,'An error handler is made of two parts, "Backoff strategy" and "Response filter". When the conditions of the response filter are met, the connector will proceed with the sync according to behavior specified. See the ',(0,o.kt)("a",{parentName:"p",href:"#response-filter"},"Response filter")," section for a detailed breakdown of possible response filter actions. In the event of a failed request that needs to be retried, the backoff strategy determines how long the connector should wait before attempting the request again. "),(0,o.kt)("p",null,"When an error handler is not configured for a stream, the connector will default to retrying requests that received a 429 and 5XX status code in the response 5 times using a 5-second exponential backoff. This default retry behavior is recommended if the API documentation does not specify error handling or retry behavior."),(0,o.kt)("p",null,"Refer to the documentation of the API you are building a connector for to determine how to handle response errors. There can either be a dedicated section listing expected error responses (ex. ",(0,o.kt)("a",{parentName:"p",href:"https://app.delighted.com/docs/api#http-status-codes"},"Delighted"),") or API endpoints will list their error responses individually (ex. ",(0,o.kt)("a",{parentName:"p",href:"https://developers.intercom.com/intercom-api-reference/reference/listcompaniesforacontact"},"Intercom"),"). There is also typically a section on rate limiting that summarizes how rate limits are communicated in the response and when to retry."),(0,o.kt)("h2",{id:"backoff-strategies"},"Backoff strategies"),(0,o.kt)("p",null,"The API documentation will usually cover when to reattempt a failed request that is retryable. This is often through a ",(0,o.kt)("inlineCode",{parentName:"p"},"429 Too Many Requests")," response status code, but it can vary for different APIs. The following backoff strategies are supported in the connector builder:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#constant"},"Constant")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#exponential"},"Exponential")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#wait-time-from-header"},"Wait time from header")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#wait-until-time-from-header"},"Wait until time from header"))),(0,o.kt)("h3",{id:"constant"},"Constant"),(0,o.kt)("p",null,'When the API documentation recommends that requests be retried after waiting a constant amount of time, the "Constant" backoff strategy should be set on the error handler.'),(0,o.kt)("h4",{id:"example"},"Example"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://developers.intercom.com/intercom-api-reference/reference/http-responses"},"Intercom API")," is an API that recommends a constant backoff strategy when retrying requests."),(0,o.kt)("h3",{id:"exponential"},"Exponential"),(0,o.kt)("p",null,'When the API documentation recommends that requests be retried after waiting an exponentially increasing amount of time, the "Exponential" backoff strategy should be set on the error handler.'),(0,o.kt)("p",null,'The exponential backoff strategy is similar to constant where the connector waits to retry a request based on a numeric value "Multiplier" defined on the connector. For a backoff strategy with "Multiplier" set to 5 seconds, when the connector receives an API response that should be retried, it will wait 5 seconds before reattempting the request. Upon receiving subsequent failed responses, the connector will wait 10, 20, 40, and 80, permanently stopping after a total of 5 retries.'),(0,o.kt)("p",null,"Note: When no backoff strategy is defined, the connector defaults to using an exponential backoff to retry requests."),(0,o.kt)("h4",{id:"example-1"},"Example"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://app.delighted.com/docs/api#rate-limits"},"Delighted API")," is an API that recommends using an exponential backoff. In this case, the API documentation recommends retrying requests after 2 seconds, 4 seconds, then 8 seconds and so on. "),(0,o.kt)("p",null,"Although a lot of API documentation does not call out using an exponential backoff, some APIs like the ",(0,o.kt)("a",{parentName:"p",href:"https://posthog.com/docs/api"},"Posthog API")," mention rate limits that are advantageous to use an exponential backoff. In this case, the rate limit of 240 requests/min should work for most syncs. However, if there is a spike in traffic, then the exponential backoff allows the connector to avoid sending more requests than the endpoint can support."),(0,o.kt)("h3",{id:"wait-time-from-header"},"Wait time from header"),(0,o.kt)("p",null,'The "Wait time from header" backoff strategy allows the connector to wait before retrying a request based on the value specified in the API response.'),(0,o.kt)("h4",{id:"example-2"},"Example"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://apidocs.chargebee.com/docs/api/error-handling"},"Chargebee API")," documentation recommends using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Retry-After")," in the response headers to determine when to retry the request."),(0,o.kt)("p",null,"When running a sync, the connector receives from the Chargebee API a response with a 429 status code and the ",(0,o.kt)("inlineCode",{parentName:"p"},"Retry-After")," header set to 60. The connector interprets the response retrieving that value from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Retry-After")," header and will pause the sync for 60 seconds before retrying."),(0,o.kt)("h3",{id:"wait-until-time-from-header"},"Wait until time from header"),(0,o.kt)("p",null,'The "Wait until time from header" backoff strategy allows the connector to wait until a specific time before retrying a request according to the API response.'),(0,o.kt)("h4",{id:"example-3"},"Example"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://recurly.com/developers/api/v2021-02-25/index.html#section/Getting-Started/Limits"},"Recurly API")," is an API that defines a header ",(0,o.kt)("inlineCode",{parentName:"p"},"X-RateLimit-Reset")," which specifies when the request rate limit will be reset. "),(0,o.kt)("p",null,"Take for example a connector that makes a request at 25/04/2023 01:00:00 GMT and receives a response with a 429 status code and the header ",(0,o.kt)("inlineCode",{parentName:"p"},"X-RateLimit-Reset")," set to 1682413200. This epoch time is equivalent to 25/04/2023 02:00:00 GMT. Using the ",(0,o.kt)("inlineCode",{parentName:"p"},"X-RateLimit-Reset")," header value, the connector will pause the sync for one hour before attempting subsequent requests to the Recurly API."),(0,o.kt)("h2",{id:"response-filter"},"Response filter"),(0,o.kt)("p",null,"A response filter should be used when a connector needs to interpret an API response to decide how the sync should proceed. Common use cases for this feature include ignoring error codes to continue fetching data, retrying requests for specific error codes, and stopping a sync based on the response received from the API."),(0,o.kt)("h3",{id:"response-conditions"},"Response conditions"),(0,o.kt)("p",null,'The following conditions can be specified on the "Response filter" and are used to determine if attributes of the response match the filter. When more than one of condition is specified, the filter will take action if the response satisfies any of the conditions:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#if-error-message-matches"},"If error message matches")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#and-predicate-is-fulfilled"},"and predicate is fulfilled")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#and-http-codes-match"},"and HTTP codes match"))),(0,o.kt)("h4",{id:"if-error-message-matches"},"If error message matches"),(0,o.kt)("p",null,'For a response filter that defines the "If error message matches" field, the connector will check if the provided text exists within the text body of the API response. If the text is present, the response filter will carry out the specified action.'),(0,o.kt)("h5",{id:"example-4"},"Example"),(0,o.kt)("p",null,"For the Chargebee API, some endpoints are only available for a specific API version and if an endpoint is unavailable, the response text will contain ",(0,o.kt)("inlineCode",{parentName:"p"},'"This API operation is not enabled for this site"'),'. The Airbyte Chargebee integration allows customers to configure which API version to use when retrieving data for a stream. When the connector makes requests to Chargebee using an unsupported version, the response filter will match according to the response text and proceeds based on the "Then execute action".'),(0,o.kt)("h4",{id:"and-predicate-is-fulfilled"},"and predicate is fulfilled"),(0,o.kt)("p",null,'This field allows for more granular control over how the response filter matches against attributes of an API response. For a filter that defines the "and predicate is fulfilled" field, the connector evaluates the interpolation expression against an API response\'s text body or headers.'),(0,o.kt)("h5",{id:"example-5"},"Example"),(0,o.kt)("p",null,"For the Zoom API, the response text body can include a special non-error status codes under the ",(0,o.kt)("inlineCode",{parentName:"p"},"code")," field. An example response text body would look like ",(0,o.kt)("inlineCode",{parentName:"p"},'{"code": 300}'),'. The "If error message matches" condition is too broad because there could be record data containing the text "300". Instead, for a response filter defining "and predicate is fulfilled" as ',(0,o.kt)("inlineCode",{parentName:"p"},"{{ response.code == 300 }}"),', during a sync, the predicate expression will be evaluated to true and the connector proceeds based on the "Then execute action".'),(0,o.kt)("h4",{id:"and-http-codes-match"},"and HTTP codes match"),(0,o.kt)("p",null,'A response filter can specify for the "and HTTP codes match" field a set of numeric HTTP status codes (ex. 200, 404, 500). When receiving an API response, the connector will check to see if the status code of the response is in the provided set of HTTP status codes.'),(0,o.kt)("h5",{id:"example-6"},"Example"),(0,o.kt)("p",null,'The Pocket API emits API responses for rate limiting errors using a 403 error status code. The default error handler interprets 403 errors as non-retryable and will fail the sync when they are encountered. The connector can configures a response filter field "and HTTP status codes" that contains 403 within the set. When a 403 error response from the API is encountered, the connector proceeds based on the "Then execute action"'),(0,o.kt)("h3",{id:"then-execute-action"},"Then execute action"),(0,o.kt)("p",null,'If a response from the API matches the predicates of the response filter the connector will continue the sync according to the "Then execute action" definition. This is a list of the actions that a connector can take:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"SUCCESS: The response was successful and the connector will extract records from the response and emit them to a destination. The connector will continue fetching the next set of records from the API."),(0,o.kt)("li",{parentName:"ul"},"RETRY: The response was unsuccessful, but the error is transient and may be successful on subsequent attempts. The request will be retried according to the backoff policy defined on the error handler."),(0,o.kt)("li",{parentName:"ul"},"IGNORE: The response was unsuccessful, but the error should be ignored. The connector will not emit any records for the current response. The connector will continue fetching the next set of records from the API."),(0,o.kt)("li",{parentName:"ul"},"FAIL: The response was unsuccessful and the connector should stop syncing records and indicate that it failed to retrieve the complete set of records.")),(0,o.kt)("h3",{id:"error-message"},"Error message"),(0,o.kt)("p",null,'The "Error message" field is used to customize the message that is relayed back to users when the API response matches a response filter that returns an error.'),(0,o.kt)("h2",{id:"multiple-error-handlers"},"Multiple error handlers"),(0,o.kt)("p",null,'In the "Error handlers" section of a stream, one or more handlers can be defined. In the case multiple error handlers are specified, the response will be evaluated against each error handler in the order they are defined. The connector will take the action of the first error handler that matches the response and ignore subsequent handlers.'))}p.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(n),u=o,f=h["".concat(l,".").concat(u)]||h[u]||p[u]||a;return n?r.createElement(f,i(i({ref:t},d),{},{components:n})):r.createElement(f,i({ref:t},d))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);